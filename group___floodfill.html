<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=windows-1251"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nmpp: Floodfill</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nmpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Поиск');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Функции</a>  </div>
  <div class="headertitle">
<div class="title">Floodfill<div class="ingroups"><a class="el" href="group__integer.html">Целочисленные функции</a> &raquo; <a class="el" href="group__nmppi_group.html">Функции обработки изображений</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Исполняет разделение бинарной картинки на односвязные области. Пример вызова: no=VL_FloodFill32b(pSrcImage, Tetr,Image, pTmpBuff, nSrcWidth, nSrcHeight);.  
<a href="#details">Подробнее...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Функции</h2></td></tr>
<tr class="memitem:gab230f3e623184077001f047628a54110"><td class="memItemLeft" align="right" valign="top"><a id="gab230f3e623184077001f047628a54110"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nmppiFloodFill</b> (unsigned int *pSrcImage, <a class="el" href="structtag_segment_info.html">SegmentInfo</a> *pSegmentInfo, unsigned int *pSegmentImage, int nWidth, int nHeight, unsigned int *pTmpBuff)</td></tr>
<tr class="separator:gab230f3e623184077001f047628a54110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab02c1bdd32988608717cb98073928894"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___floodfill.html#gab02c1bdd32988608717cb98073928894">FloodFill8</a> (void *src, void *dst, int nWidth, int nHeight, <a class="el" href="structspot__struct.html">spot_struct</a> *spot, int lenSpot, unsigned *pixels, int mSpot, int dtFull, int dtSpot, int lDiag, int lDropSpot, <a class="el" href="structds__struct.html">ds_struct</a> *dropSpot, int nPxlMin, int nPxlMax, int dXYmin, int dXYmax)</td></tr>
<tr class="memdesc:gab02c1bdd32988608717cb98073928894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Функция FloodFill8 выполняет поиск пятен (сегментов, односвязных областей) во входной 8-битной матрице (изображения в градациях серого от 0 до 255), и строит такие же пятна в выходной матрице, заполняя их одним и тем же значением (цветом, соответствующим номеру пятна).  <a href="group___floodfill.html#gab02c1bdd32988608717cb98073928894">Подробнее...</a><br /></td></tr>
<tr class="separator:gab02c1bdd32988608717cb98073928894"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<p>Исполняет разделение бинарной картинки на односвязные области. Пример вызова: no=VL_FloodFill32b(pSrcImage, Tetr,Image, pTmpBuff, nSrcWidth, nSrcHeight);. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSrcImage</td><td>Входное изображение</td></tr>
    <tr><td class="paramname">pSegmentInfo</td><td>массив структур, где содержатся минимальные и максимальные координаты прямоугольника, описывающего сегментированную область.</td></tr>
    <tr><td class="paramname">nWidth</td><td>ширина изображения</td></tr>
    <tr><td class="paramname">nHeight</td><td>высота изображения</td></tr>
    <tr><td class="paramname">pTmpBuff</td><td>Временный массив. Его размер должен быть 2*nWidth*nHeight</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Возвращаемые значения</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pSegmentImage</td><td>Результирующее "изображение", где все точки одного сегмента имеют одинаковое значение (1,...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd><em>Число</em> сегментов на изображении</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>Массив pSegmentImage дожен быть обнулен. Функция изменяет массив pSrcImage. </dd></dl>
<h2 class="groupheader">Функции</h2>
<a id="gab02c1bdd32988608717cb98073928894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab02c1bdd32988608717cb98073928894">&#9670;&nbsp;</a></span>FloodFill8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FloodFill8 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspot__struct.html">spot_struct</a> *&#160;</td>
          <td class="paramname"><em>spot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lenSpot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mSpot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtFull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtSpot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lDiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lDropSpot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structds__struct.html">ds_struct</a> *&#160;</td>
          <td class="paramname"><em>dropSpot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPxlMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPxlMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dXYmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dXYmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Функция FloodFill8 выполняет поиск пятен (сегментов, односвязных областей) во входной 8-битной матрице (изображения в градациях серого от 0 до 255), и строит такие же пятна в выходной матрице, заполняя их одним и тем же значением (цветом, соответствующим номеру пятна). </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>входная 8-битная матрица размером nHeight x nWidth. <br  />
 <b>Внимание</b>. Входная матрица src модифицируется: <ul>
<li>в целях оптимизации программы обнуляются верхняя и нижняя строки, и крайний левый и крайний правый столбцы (границы матрицы), </li>
<li>в процессе обработки найденные пятна обнуляются.</li>
</ul>
</td></tr>
    <tr><td class="paramname">dst</td><td>результирующая 8-битная матрица того же размера nHeight x nWidth. <br  />
 <b>Внимание</b>. Перед обращением к функции выходная матрица dst должна быть обнулена.</td></tr>
    <tr><td class="paramname">nWidth</td><td>ширина входной (и выходной) матрицы в 8-битных элементах.<br  />
 <b>Ограничения</b>. Ширина матрицы должна быть кратна 32-битным словам: nWidth - положительное, (nWidth &amp; 3) = 0.</td></tr>
    <tr><td class="paramname">nHeight</td><td>высота входной (и выходной) матрицы. <br  />
 <b>Ограничения</b>. Высота матрицы не должна превышать 1080 строк: nHeight - положительное, (nHeight &lt;= 1080). Это ограничение можно обойти задав в начале файла FloodFill8.asm вместо 1080 нужное значение константы: const NHEIGHT = 1080;</td></tr>
    <tr><td class="paramname">spot</td><td>массив, содержащий обобщенную информацию о найденных пятнах – минимально 6 параметров формата int для каждого пятна: <b>Замечание1</b>. Чтобы гарантированно избежать переполнения массива spot в общем случае (когда характер матрицы, количество, размер пятен неизвестны, и не задан параметр mSpot&gt;0), размер массива spot в 32-битных словах должен быть: ( nSpotMax + 1 + [(nSpotMax-1)/255] ) * lenSpot, nSpotMax = [(nHeight-2)*(nWidth-2)/2 + 0.5], при lDiag=0, = [(nHeight-2)/2+0.5] * [(nWidth-2)/2+0.5], при lDiag=1, квадратные скобки [...] обозначают целую часть числа, напомним: 2 строки и 2 солбца входной матрицы обнулены. <b>Замечание2</b>. Если задан параметр mSpot&gt;0, то массив spot достаточно определить для mSpot пятен (mSpot задается с учетом служебного и фиктивных пятен).</td></tr>
    <tr><td class="paramname">lenSpot</td><td>размер пятна в 32-битных словах, позволяет задать размер пятна более 6 слов, резервируя место для дополнительных параметров пятна довычисляемых другими функциями (например, угол наклона пятна к горизонтальной оси…). <br  />
 <b>Замечание</b>. Если параметр lenSpot задан некорректно lenSpot&lt;6, то ему присваивается минимальное возможное значение lenSpot=6.</td></tr>
    <tr><td class="paramname">pixels</td><td>массив координат пикселов, принадлежащих найденным пятнам, каждый элемент массива состоит из одного 32 битного слова, включающего в себя координаты пиксела в матрице src (или dst): unsigned int ij; биты [31..16] - i - номер строки, биты [15..0] - j - номер столбца. (Отсюда ограничение: nHeight, nWidth не могут быть больше 2**16-1 = 65535). <br  />
 <b>Замечание</b>. В общем случае (когда заранее неизвестно о количестве и размерах пятен в матрице), чтобы гарантированно избежать переполнения массива pixels, его размер должен быть (nHeight-2)*(nWidth-2) 32-битных слов (что почти в 4 раза больше входной 8-битной матрицы, напомним: 2 строки и 2 солбца входной матрицы обнулены).</td></tr>
    <tr><td class="paramname">mSpot</td><td>число пятен, ограничивающее поиск. Если задано mSpot&gt;0, то после обработки очередного пятна проверяется: достигло ли количество найденных пятен nSpot заданного mSpot (mSpot&lt;=nSpot)? Если «Да», то происходит (принудительный) выход из программы с записью в spot[0].Ymin=2. Если задано mSpot=0, то проверок на количество найденных пятен не производится. <br  />
 <b>Замечание1</b>. Если задать mSpot&lt;=255, то пятна будут однозначно соответствовать своим номерам, то есть не будет пятен с повторяющимися номерами. <br  />
 <b>Замечание2</b>. mSpot следует задавать с учетом служебного пятна (с номером 0) и фиктивных пятен (с номерами 256,512,768...), то есть, если поиск надо ограничить нахождением первых mSpotReal&gt;0 пятен, то mSpot = 1 + mSpotReal + [(mSpotReal-1)/255] квадратные скобки [...] обозначают целую часть числа</td></tr>
    <tr><td class="paramname">dtFull</td><td>время, выделенное на работу программы (в тактах процессора). Если задано dtFull&gt;0, то после обработки очередного пятна (и в конце каждой строки) проверяется: осталось ли время на обработку следующего пятна dtRest&lt;dtSpot? (dtRest=dtFull-(T-T0), T – текущее время, T0 – начало работы программы). Если «Нет», то происходит выход из программы с записью в spot[0].Ymin=1. Если задано dtFull=0, то проверок на достаточность времени на обработку следующего пятна не производится. <br  />
 <b>Замечание1</b>. Задание dtFull&gt;0 маленьким может значительно сократить время работы программы, однако, не гарантирует корректного завершения программы (например, когда обрабатываемое пятно занимает всю оставшуюся часть матрицы). <br  />
 <b>Замечание2</b>. При выборе значения dtFull следует учитывать время обработки типового пятна dtSpot.</td></tr>
    <tr><td class="paramname">dtSpot</td><td>время обработки типового пятна (в тактах процессора). Используется совместно с параметром dtFull при оценке достаточного времени на обработку следующего пятна. <br  />
 <b>Ограничение</b>. Если задано dtFull&gt;0, то dtSpot должно быть меньше него: dtSpot - неотрицательное, (dtFull&gt;0)&amp;&amp;(dtSpot&lt;dtFull).</td></tr>
    <tr><td class="paramname">lDiag</td><td>параметр, определяющий связность пятна по диагоналям: <ul>
<li>lDiag=0 - элементы являются соседними, если они граничат или по вертикали, или по горизонтали (по ходам ладьи, но не по ходам слона), </li>
<li>lDiag=1 - элементы являются соседними, если они граничат или по вертикали, или по горизонтали, или по диагоналям (по ходам ферзя).</li>
</ul>
<br  />
 <b>Замечание</b>. Как показывает практика, результат обработки видеоизображений существенно не зависит от параметра lDiag, но при lDiag=1 значительно увеличивает время работы функции. Если нет особой необходимости, рекомендуется задавать lDiag=0.</td></tr>
    <tr><td class="paramname">lDropSpot</td><td>параметр, задающий необходимость отбраковки найденных пятен по условиям НЕвхождения числа пикселов или размеров пятна в заданные диапазоны (см. ниже параметры nPxlmin, nPxlmax, dXYmin, dXYmax), статистика по отбракованным пятнам ведется в массиве dropSpot. <br  />
 lDropSpot=0 – найденные пятна НЕ отбраковываются, то есть все найденные пятна учитываются в массивах spot, pixels и отмечаются в выходной матрице dst, <br  />
 lDropSpot=1 – пятна с числом пикселов или размеров пятна не попадающими в заданные диапазоны отбраковываются, то есть не учитываются в массивах spot, pixels и не отмечаются в выходной матрице dst, статистика по отбракованным пятнам ведется в массиве dropSpot. <br  />
 <b>Замечание</b>. Задание параметра lDropSpot=1 приводит к увеличению работы функции и требует выделения памяти для массива dropSpot. Если нет особой необходимости, задавайте lDropSpot=0.</td></tr>
    <tr><td class="paramname">dropSpot</td><td>– массив, в который опционально собирается статистика по отбракованным пятнам: на каждый из 4 признаков отбраковки: nPxlMin, nPxlMax, dXYmin, dXYmax, - отведено по 3 параметра формата int: dropSpot[4*3] +0 +1 +2 <ul>
<li>0 – dropSpot(nPxlMin): [ nnSpot, nnPxl, dttSpot] </li>
<li>3 - dropSpot(nPxlMax): [ nnSpot, nnPxl, dttSpot] </li>
<li>6 - dropSpot(dXYmin) : [ nnSpot, nnPxl, dttSpot] </li>
<li>9 - dropSpot(dXYmax) : [ nnSpot, nnPxl, dttSpot]</li>
</ul>
<br  />
 <b>Перед</b> обращением к функции массив dropSpot (размером 12 int) должен быть обнулен. <br  />
 <b>При</b> ldropSpot=0 статистика не ведется и массив dropSpot не требуется, то есть вместо него можно задать фиктивный параметр, например, 0.</td></tr>
    <tr><td class="paramname">nPxlMin</td><td>минимальное число пикселов в пятне, <br  />
 при lDropSpot=1: пятно отбраковывается, если число его пикселов меньше nPxlMin, <br  />
 при lDropSpot=0 проверок не производится, параметр можно задать 0.</td></tr>
    <tr><td class="paramname">nPxlMax</td><td>максимальное число пикселов в пятне, <ul>
<li>при lDropSpot=1: пятно отбраковывается, если число его пикселов больше nPxlMax, </li>
<li>при lDropSpot=0 проверок не производится, параметр можно задать 0.</li>
</ul>
</td></tr>
    <tr><td class="paramname">dXYmin</td><td>минимальная протяженность пятна по X или по Y в пикселах, <ul>
<li>при lDropSpot=1: пятно отбраковывается, если его протяженность меньше dXYMax, </li>
<li>при lDropSpot=0 проверок не производится, но параметр используется для определения шага поиска по строкам входной матрицы src (и начальной строки поиска): dI = max(1, dXYmin) <br  />
 <b>Замечание</b>. Задание dXYmin&gt;1 приводит к просмотру входной матрицы src через каждые dXYmin строк, что может значительно сократить время работы функции, так как пятна меньшего размера, попавшие между строк поиска "обходятся" (однако, не гарантирует этого, например, когда пятно занимает всю матрицу). Поэтому, независимо от парамера lDropSpot надо задавать dXYmin, по возможности, большим.</li>
</ul>
</td></tr>
    <tr><td class="paramname">dXYmax</td><td>максимальная протяженность пятна по X или по Y в пикселах, <ul>
<li>при lDropSpot=1: пятно отбраковывается, если его протяженность больше dXYMax, </li>
<li>при lDropSpot=0 проверок не производится, параметр можно задать 0.</li>
</ul>
<br  />
 <b>Ограничения:</b> nPxlMin, nPxlMax, dXYmin, dXYmax - неотрицательные, (nPxlMin &lt;= nPxlMax), (dXYmin &lt;= dXYmax).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd><em>Функция</em> возвращает целое число: <br  />
 <ul>
<li>либо положительное целое, тогда это - nSpot - число найденных пятен, </li>
<li>либо отрицательное целое, тогда это - nError - код ошибки.</li>
</ul>
Число найденных пятен nSpot включает в себя также служебное и фиктивные пятна (с номерами 0,256,512,768...). Таким образом, число реальных пятен равно nSpotReal = nSpot - 1 - [nSpot/256] <br  />
 Если не найдено ни одного реального пятна, то nSpot=1 – одно служебное пятно. <br  />
 Код ошибки возвращается, если в начале работы функции при проверке входных данных обнаружится недопустимая комбинация параметров: тогда происходит (принудительный) выход из программы с кодом ошибки: <pre class="fragment">                        dI = max(1,dXYmin);
                        if ( (nHeight&lt;=0) || (nHeight &lt; dI +2) || (1080&lt;nHeight) )  return -1;
                        if ( (nWidth &lt;=0) || (nWidth  &lt; dI +2) ||((nWidth &amp; 3)!=0)) return -2;
                        if ( (dtSpot  &lt;0) || ((dtFull != 0) &amp;&amp; (dtFull &lt; dtSpot)) )     return -3;
                        if ( (nPxlMin &lt;0) || (nPxlMax &lt; nPxlMin) )      return -4;
                        if ( (dXYmin  &lt;0) || (dXYmax  &lt; dXYmin)  )      return -5;
                        if   (mSpot   &lt;0)                                       return -6;</pre> При нормальном выходе из функции (без ошибок) в параметре Ymin служебного пятна сообщается дополнительный признак завершения программы nExitCode: <ul>
<li>spot[0].Ymin=0 – вся матрица src просмотрена, найдены все пятна, естественный выход из программы. </li>
<li>spot[0].Ymin=1 – принудительный выход из программы по исчерпанию заданного времени работы программы dtFull&gt;0. </li>
<li>spot[0].Ymin=2 – принудительный выход из программы по нахождению заданного количества пятен mSpot&gt;0.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd><b>Предельные</b> <b>случаи</b> <br  />
Следует выделить предельные случаи: <ul>
<li>одно сплошное пятно на всю матрицу - максимальное время работы функции и максимальный размер массива pixels (но минимальный размер массива spot), </li>
<li>«шахматная доска» - однопикселные пятна, расположенные по диагоналям - максимальный размер массива spot.</li>
</ul>
</dd>
<dd>
<b>Алгоритм</b> <br  />
В процессе поиска координаты всех пикселов каждого пятна сохраняются в массиве pixels:<ul>
<li>пикселы каждого пятна занимают непрерывную область в массиве pixels,</li>
<li>параметр spot[i].noPxl i-го пятна в массиве spot указывает на начальный пиксел (i+1)-го пятна. В начале работы программы устанавливается указатель на начальный пиксел следующего пятна noPxl = 0. <pre class="fragment">1. Цикл поиск пятна (осуществляется построчным попиксельным проходом матрицы src),
если очередной пиксел нулевой, то переход к следующему пикселу
иначе (встретился ненулевой пиксел)
2. начало обработки (очередного) пятна:
-       засечь время начала обработки пятна  tSpot0=clock();
-       устанавливаются указатели начала и конца очереди пикселов пятна в массиве  pixels:  noPxl0 = noPxl1 = noPxl.
-       пиксел в матрице src обнуляется,
-       координаты пиксела заносятся в массив pixels, указатель noPxl1  увеличивается на 1
        3. while-цикл обработки пятна:
-       выбирается пиксел noPxl0 из массива pixels, указатель noPxl0  увеличивается на 1
-       просматриваются все его соседние элементы (с учетом параметра lDiag) координаты ненулевых пикселов записываются в массив pixels (с соответствующим увеличением указателя noPxl1)
-       пикселы в матрице src обнуляются
-       если указатели  noPxl0, noPxl1  не равны (не все пикселы пятна и их соседи просмотрены), то переход на начало while-цикла (3):
// пятно найдено! noPxl0=noPxl1 - указывают на начальный пиксел
//следующего пятна в массиве  pixels.
Вычисление минимального прямоугольника (Xmin, Ymin, Xmax, Ymax), объемлющего пятно
Если задан параметр lDropSpot=1, то проверка условий отбраковки пятна по признакам nPxlMin, nPxlMax, dXYmin, dXYmax
если пятно отбраковано, то
формирование записи массива dropSpot по соответствующему признаку,
переход на поиск следующего пятна  (noPxl не изменяется).
Меняется указатель  noPxl=noPxl1.
Формирование параметров данного пятна в массиве spot[i] =
(Xmin, Ymin, Xmax, Ymax, noPxl, 0, 0, 0)
        Если задан параметр вычисления угла наклона пятна (lAngleSpot=1), то
вычисление codeAngle, lBadSpot и запись в spot[i] =
(., ., ., ., ., codeAngle, lBadSpot, .)
Запись dtSpot=clock()-tSpot0 в spot[i] = (., ., ., ., ., ., ., dtSpot).
Выбор следующегл пиксела, переход на начало цикла поиска очередного пятна (1).
4. Конец программы.
</pre> </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Документация по nmpp. Последние изменения: Вт 19 Окт 2021 12:31:05. Создано системой&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
